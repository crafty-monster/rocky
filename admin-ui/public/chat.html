<!DOCTYPE html>
<html lang="en">
 <head>
   <meta charset="UTF-8" />
   <meta name="viewport" content="width=device-width, initial-scale=1.0" />
   <meta http-equiv="X-UA-Compatible" content="ie=edge" />
   <title>Rocky Chat | Minecraft Bedrock Server Controller</title>
   <link
     href="https://fonts.googleapis.com/css?family=Montserrat:300,400,500,700&display=swap"
     rel="stylesheet" />
   <link rel="stylesheet" href="./css/fontawesome/all.css" />
   <link rel="stylesheet" href="./chat.css" />
   <style>
  </style>
  <script src="./scripts/alpinejs@3.14.1.min.js" defer></script>
   <script src="./scripts/socket.io@4.7.5.min.js"></script>
 </head>
 <body>
    <div x-data="app" class="container">
      <ul class="users">
        <template x-for="socketId in users">
          <li @click="() => call(socketId)">
            <i class="fa-regular fa-user fa-2xl"></i>
            <div class="avatar-name" x-text="socketId"></div>
            <div class="remote-video">
              <video autoplay :id="'remote-video-' + socketId"></video>
            </div>
          </li>
        </template>
      </ul>
      <div class="local-video">
        <div class="avatar-name">Me</div>
        <video autoplay muted id="local-video" :class="connected ? '' : 'disconnected'"></video>
      </div>
      <div class="toggle" @click="() => connected ? disconnect() : startVideo()" :class="connected ? 'connected' : ''">
        <i class="fa-solid fa-phone fa-2xl"></i>
      </div>
    </div>
   <script>

const { RTCPeerConnection, RTCSessionDescription } = window;

document.addEventListener('alpine:init', () => {
  Alpine.data('app', () => ({
    socket: undefined,
    remoteSocket: undefined,
    users: [],
    isAlreadyCalling: false,
    getCalled: false,
    connected: false,
    localStream: undefined,
    peerConnection: undefined,

    async init() {
      const socket = this.socket = io({ path: '/chat' });
      socket.on("update-user-list", ({ users }) => {
        this.users  = users;
      });
      socket.on("remove-user", ({ socketId }) => {
        this.users.splice(this.users.indexOf(socketId), 1);
      });

      socket.on("call-made", async data => {
        if (this.getCalled) {
          const confirmed = confirm(`User "Socket: ${data.socket}" wants to call you. Do accept this call?`);
          if (!confirmed) {
            return socket.emit("reject-call", { from: data.socket });
          }
          this.remoteSocket = data.socket;
        }
        const peerConnection = this.peerConnection;
        await peerConnection.setRemoteDescription(new RTCSessionDescription(data.offer));
        const answer = await peerConnection.createAnswer();
        await peerConnection.setLocalDescription(new RTCSessionDescription(answer));
        socket.emit("make-answer", { answer, to: data.socket });
        this.getCalled = true;
      });
      socket.on("answer-made", async data => {
        console.log('answer-made', data);
        this.remoteSocket = data.socket;
        await this.peerConnection.setRemoteDescription(new RTCSessionDescription(data.answer));
        if (!this.isAlreadyCalling) {
          this.call(data.socket);
          this.isAlreadyCalling = true;
        }
      });
      socket.on("call-rejected", data => {
        alert(`User: "Socket: ${data.socket}" rejected your call.`);
        this.remoteSocket = undefined;
        // unselectUsersFromList();
      });
      socket.on("too-many-users", (count) => {
        alert(`Too many users! We reached the maximum of ${count} users on this chat. Please try again later.`);
        setTimeout(() => this.disconnect(), 1000);
      });
      this.startVideo();
    },

    startVideo() {
      const peerConnection = this.peerConnection = this.peerConnection || new RTCPeerConnection();
      peerConnection.ontrack = ({ streams: [stream] }) => {
        console.log('received stream', stream);
        const selector = `remote-video-${this.remoteSocket}`; 
        const remoteVideo = document.getElementById(selector);
        if (remoteVideo) {
          remoteVideo.srcObject = stream;
        } else {
          console.log('Cannot find video tag', selector);
        }
      };
      navigator.getUserMedia(
        { video: true, audio: true },
        stream => {
          this.localStream = stream;
          const localVideo = document.getElementById("local-video");
          if (localVideo) {
            localVideo.srcObject = stream;
          }
          stream.getTracks().forEach(track => peerConnection.addTrack(track, stream));
          this.connected = true;
        },
        e => console.warn(e.message)
      );
    },

    async call(socketId) {
      console.log('call', socketId);
      const offer = await this.peerConnection.createOffer();
      await this.peerConnection.setLocalDescription(new RTCSessionDescription(offer));

      this.socket.emit("call-user", { offer, to: socketId });
    },

    disconnect() {
      const localVideo = document.getElementById("local-video");
      if (localVideo) { 
        localVideo.pause();
      }
      if (this.localStream) {
        this.localStream.getTracks().forEach(t => t.stop());
      }
      this.connected = false;
    }
  }));
});

   </script>
 </body>
</html>